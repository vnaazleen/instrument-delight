{"ast":null,"code":"'use strict';\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @license Angular v14.0.0-next.5\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis}\n   */\n\n  var NEWLINE = '\\n';\n  var IGNORE_FRAMES = {};\n  var creationTrace = '__creationTrace__';\n  var ERROR_TAG = 'STACKTRACE TRACKING';\n  var SEP_TAG = '__SEP_TAG__';\n  var sepTemplate = SEP_TAG + '@[native]';\n\n  var LongStackTrace =\n  /** @class */\n  function () {\n    function LongStackTrace() {\n      this.error = getStacktrace();\n      this.timestamp = new Date();\n    }\n\n    return LongStackTrace;\n  }();\n\n  function getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n  }\n\n  function getStacktraceWithCaughtError() {\n    try {\n      throw getStacktraceWithUncaughtError();\n    } catch (err) {\n      return err;\n    }\n  } // Some implementations of exception handling don't create a stack trace if the exception\n  // isn't thrown, however it's faster not to actually throw the exception.\n\n\n  var error = getStacktraceWithUncaughtError();\n  var caughtError = getStacktraceWithCaughtError();\n  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\n  function getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n  }\n\n  function addErrorStack(lines, error) {\n    var trace = getFrames(error);\n\n    for (var i = 0; i < trace.length; i++) {\n      var frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n        lines.push(trace[i]);\n      }\n    }\n  }\n\n  function renderLongStackTrace(frames, stack) {\n    var longTrace = [stack ? stack.trim() : ''];\n\n    if (frames) {\n      var timestamp = new Date().getTime();\n\n      for (var i = 0; i < frames.length; i++) {\n        var traceFrames = frames[i];\n        var lastTime = traceFrames.timestamp;\n        var separator = \"____________________Elapsed \".concat(timestamp - lastTime.getTime(), \" ms; At: \").concat(lastTime);\n        separator = separator.replace(/[^\\w\\d]/g, '_');\n        longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n        addErrorStack(longTrace, traceFrames.error);\n        timestamp = lastTime.getTime();\n      }\n    }\n\n    return longTrace.join(NEWLINE);\n  } // if Error.stackTraceLimit is 0, means stack trace\n  // is disabled, so we don't need to generate long stack trace\n  // this will improve performance in some test(some test will\n  // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\n  function stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n  }\n\n  Zone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function (error) {\n      if (!error) {\n        return undefined;\n      }\n\n      var trace = error[Zone.__symbol__('currentTaskTrace')];\n\n      if (!trace) {\n        return error.stack;\n      }\n\n      return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (stackTracesEnabled()) {\n        var currentTask = Zone.currentTask;\n        var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n        trace = [new LongStackTrace()].concat(trace);\n\n        if (trace.length > this.longStackTraceLimit) {\n          trace.length = this.longStackTraceLimit;\n        }\n\n        if (!task.data) task.data = {};\n\n        if (task.type === 'eventTask') {\n          // Fix issue https://github.com/angular/zone.js/issues/1195,\n          // For event task of browser, by default, all task will share a\n          // singleton instance of data object, we should create a new one here\n          // The cast to `any` is required to workaround a closure bug which wrongly applies\n          // URL sanitization rules to .data access.\n          task.data = Object.assign({}, task.data);\n        }\n\n        task.data[creationTrace] = trace;\n      }\n\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (stackTracesEnabled()) {\n        var parentTask = Zone.currentTask || error.task;\n\n        if (error instanceof Error && parentTask) {\n          var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n          try {\n            error.stack = error.longStack = longStack;\n          } catch (err) {}\n        }\n      }\n\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  };\n\n  function captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n      stackTraces.push(getFrames(new LongStackTrace().error));\n      captureStackTraces(stackTraces, count - 1);\n    }\n  }\n\n  function computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n      return;\n    }\n\n    var frames = [];\n    captureStackTraces(frames, 2);\n    var frames1 = frames[0];\n    var frames2 = frames[1];\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n\n      if (frame1.indexOf(ERROR_TAG) == -1) {\n        var match = frame1.match(/^\\s*at\\s+/);\n\n        if (match) {\n          sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n      var frame2 = frames2[i];\n\n      if (frame1 === frame2) {\n        IGNORE_FRAMES[frame1] = true;\n      } else {\n        break;\n      }\n    }\n  }\n\n  computeIgnoreFrames();\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ProxyZoneSpec =\n  /** @class */\n  function () {\n    function ProxyZoneSpec(defaultSpecDelegate) {\n      if (defaultSpecDelegate === void 0) {\n        defaultSpecDelegate = null;\n      }\n\n      this.defaultSpecDelegate = defaultSpecDelegate;\n      this.name = 'ProxyZone';\n      this._delegateSpec = null;\n      this.properties = {\n        'ProxyZoneSpec': this\n      };\n      this.propertyKeys = null;\n      this.lastTaskState = null;\n      this.isNeedToTriggerHasTask = false;\n      this.tasks = [];\n      this.setDelegate(defaultSpecDelegate);\n    }\n\n    ProxyZoneSpec.get = function () {\n      return Zone.current.get('ProxyZoneSpec');\n    };\n\n    ProxyZoneSpec.isLoaded = function () {\n      return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    };\n\n    ProxyZoneSpec.assertPresent = function () {\n      if (!ProxyZoneSpec.isLoaded()) {\n        throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n      }\n\n      return ProxyZoneSpec.get();\n    };\n\n    ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n      var _this = this;\n\n      var isNewDelegate = this._delegateSpec !== delegateSpec;\n      this._delegateSpec = delegateSpec;\n      this.propertyKeys && this.propertyKeys.forEach(function (key) {\n        return delete _this.properties[key];\n      });\n      this.propertyKeys = null;\n\n      if (delegateSpec && delegateSpec.properties) {\n        this.propertyKeys = Object.keys(delegateSpec.properties);\n        this.propertyKeys.forEach(function (k) {\n          return _this.properties[k] = delegateSpec.properties[k];\n        });\n      } // if a new delegateSpec was set, check if we need to trigger hasTask\n\n\n      if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n        this.isNeedToTriggerHasTask = true;\n      }\n    };\n\n    ProxyZoneSpec.prototype.getDelegate = function () {\n      return this._delegateSpec;\n    };\n\n    ProxyZoneSpec.prototype.resetDelegate = function () {\n      this.getDelegate();\n      this.setDelegate(this.defaultSpecDelegate);\n    };\n\n    ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n      if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n        // last delegateSpec has microTask or macroTask\n        // should call onHasTask in current delegateSpec\n        this.isNeedToTriggerHasTask = false;\n        this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n      }\n    };\n\n    ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n      if (!this.tasks) {\n        return;\n      }\n\n      for (var i = 0; i < this.tasks.length; i++) {\n        if (this.tasks[i] === task) {\n          this.tasks.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n      if (this.tasks.length === 0) {\n        return '';\n      }\n\n      var taskInfo = this.tasks.map(function (task) {\n        var dataInfo = task.data && Object.keys(task.data).map(function (key) {\n          return key + ':' + task.data[key];\n        }).join(',');\n        return \"type: \".concat(task.type, \", source: \").concat(task.source, \", args: {\").concat(dataInfo, \"}\");\n      });\n      var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']'; // clear tasks\n\n      this.tasks = [];\n      return pendingTasksInfo;\n    };\n\n    ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n      if (this._delegateSpec && this._delegateSpec.onFork) {\n        return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n      } else {\n        return parentZoneDelegate.fork(targetZone, zoneSpec);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n      if (this._delegateSpec && this._delegateSpec.onIntercept) {\n        return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n      } else {\n        return parentZoneDelegate.intercept(targetZone, delegate, source);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvoke) {\n        return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n      } else {\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (this._delegateSpec && this._delegateSpec.onHandleError) {\n        return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n      } else {\n        return parentZoneDelegate.handleError(targetZone, error);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.tasks.push(task);\n      }\n\n      if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n        return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.scheduleTask(targetZone, task);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n        return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n      } else {\n        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n        return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.cancelTask(targetZone, task);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n      this.lastTaskState = hasTaskState;\n\n      if (this._delegateSpec && this._delegateSpec.onHasTask) {\n        this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n      } else {\n        delegate.hasTask(target, hasTaskState);\n      }\n    };\n\n    return ProxyZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var SyncTestZoneSpec =\n  /** @class */\n  function () {\n    function SyncTestZoneSpec(namePrefix) {\n      this.runZone = Zone.current;\n      this.name = 'syncTestZone for ' + namePrefix;\n    }\n\n    SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n        case 'macroTask':\n          throw new Error(\"Cannot call \".concat(task.source, \" from within a sync test.\"));\n\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n\n      return task;\n    };\n\n    return SyncTestZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  Zone.__load_patch('jasmine', function (global, Zone, api) {\n    var __extends = function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n    if (!Zone) throw new Error('Missing: zone.js');\n\n    if (typeof jest !== 'undefined') {\n      // return if jasmine is a light implementation inside jest\n      // in this case, we are running inside jest not jasmine\n      return;\n    }\n\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n      return;\n    }\n\n    jasmine['__zone_patch__'] = true;\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n    var ambientZone = Zone.current; // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n    // error if any asynchronous operations are attempted inside of a `describe` but outside of\n    // a `beforeEach` or `it`.\n\n    var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n    var symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n    var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n\n    var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n    var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n    if (!ignoreUnhandledRejection) {\n      var globalErrors_1 = jasmine.GlobalErrors;\n\n      if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n        jasmine[symbol('GlobalErrors')] = globalErrors_1;\n\n        jasmine.GlobalErrors = function () {\n          var instance = new globalErrors_1();\n          var originalInstall = instance.install;\n\n          if (originalInstall && !instance[symbol('install')]) {\n            instance[symbol('install')] = originalInstall;\n\n            instance.install = function () {\n              var originalHandlers = process.listeners('unhandledRejection');\n              var r = originalInstall.apply(this, arguments);\n              process.removeAllListeners('unhandledRejection');\n\n              if (originalHandlers) {\n                originalHandlers.forEach(function (h) {\n                  return process.on('unhandledRejection', h);\n                });\n              }\n\n              return r;\n            };\n          }\n\n          return instance;\n        };\n      }\n    } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n    var jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n\n      jasmineEnv[methodName] = function (description, specDefinitions) {\n        return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n      };\n    });\n    ['it', 'xit', 'fit'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n        arguments[1] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (specDefinitions, timeout) {\n        arguments[0] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n\n    if (!disablePatchingJasmineClock) {\n      // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n      // they can work properly in FakeAsyncTest\n      var originalClockFn_1 = jasmine[symbol('clock')] = jasmine['clock'];\n\n      jasmine['clock'] = function () {\n        var clock = originalClockFn_1.apply(this, arguments);\n\n        if (!clock[symbol('patched')]) {\n          clock[symbol('patched')] = symbol('patched');\n          var originalTick_1 = clock[symbol('tick')] = clock.tick;\n\n          clock.tick = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n            }\n\n            return originalTick_1.apply(this, arguments);\n          };\n\n          var originalMockDate_1 = clock[symbol('mockDate')] = clock.mockDate;\n\n          clock.mockDate = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n              return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n            }\n\n            return originalMockDate_1.apply(this, arguments);\n          }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n          if (enableAutoFakeAsyncWhenClockPatched) {\n            ['install', 'uninstall'].forEach(function (methodName) {\n              var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n              clock[methodName] = function () {\n                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n                if (FakeAsyncTestZoneSpec) {\n                  jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                  return;\n                }\n\n                return originalClockFn.apply(this, arguments);\n              };\n            });\n          }\n        }\n\n        return clock;\n      };\n    } // monkey patch createSpyObj to make properties enumerable to true\n\n\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n      var originalCreateSpyObj_1 = jasmine.createSpyObj;\n      jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n\n      jasmine.createSpyObj = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var propertyNames = args.length >= 3 ? args[2] : null;\n        var spyObj;\n\n        if (propertyNames) {\n          var defineProperty_1 = Object.defineProperty;\n\n          Object.defineProperty = function (obj, p, attributes) {\n            return defineProperty_1.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n              configurable: true,\n              enumerable: true\n            }));\n          };\n\n          try {\n            spyObj = originalCreateSpyObj_1.apply(this, args);\n          } finally {\n            Object.defineProperty = defineProperty_1;\n          }\n        } else {\n          spyObj = originalCreateSpyObj_1.apply(this, args);\n        }\n\n        return spyObj;\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        return syncZone.run(describeBody, this, arguments);\n      };\n    }\n\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n      var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n      queueRunner.testProxyZoneSpec;\n      var testProxyZone = queueRunner.testProxyZone;\n\n      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n        // auto run a fakeAsync\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      if (done) {\n        return testProxyZone.run(testBody, applyThis, [done]);\n      } else {\n        return testProxyZone.run(testBody, applyThis);\n      }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n\n\n    function wrapTestInZone(testBody) {\n      // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jasmine will\n      // think that all functions are sync or async.\n      return testBody && (testBody.length ? function (done) {\n        return runInTestZone(testBody, this, this.queueRunner, done);\n      } : function () {\n        return runInTestZone(testBody, this, this.queueRunner);\n      });\n    }\n\n    var QueueRunner = jasmine.QueueRunner;\n\n    jasmine.QueueRunner = function (_super) {\n      __extends(ZoneQueueRunner, _super);\n\n      function ZoneQueueRunner(attrs) {\n        var _this = this;\n\n        if (attrs.onComplete) {\n          attrs.onComplete = function (fn) {\n            return function () {\n              // All functions are done, clear the test zone.\n              _this.testProxyZone = null;\n              _this.testProxyZoneSpec = null;\n              ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n            };\n          }(attrs.onComplete);\n        }\n\n        var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n        var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n        if (nativeSetTimeout) {\n          // should run setTimeout inside jasmine outside of zone\n          attrs.timeout = {\n            setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n          };\n        } // create a userContext to hold the queueRunner itself\n        // so we can access the testProxy in it/xit/beforeEach ...\n\n\n        if (jasmine.UserContext) {\n          if (!attrs.userContext) {\n            attrs.userContext = new jasmine.UserContext();\n          }\n\n          attrs.userContext.queueRunner = this;\n        } else {\n          if (!attrs.userContext) {\n            attrs.userContext = {};\n          }\n\n          attrs.userContext.queueRunner = this;\n        } // patch attrs.onException\n\n\n        var onException = attrs.onException;\n\n        attrs.onException = function (error) {\n          if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n            // jasmine timeout, we can make the error message more\n            // reasonable to tell what tasks are pending\n            var proxyZoneSpec = this && this.testProxyZoneSpec;\n\n            if (proxyZoneSpec) {\n              var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n              try {\n                // try catch here in case error.message is not writable\n                error.message += pendingTasksInfo;\n              } catch (err) {}\n            }\n          }\n\n          if (onException) {\n            onException.call(this, error);\n          }\n        };\n\n        _super.call(this, attrs);\n      }\n\n      ZoneQueueRunner.prototype.execute = function () {\n        var _this = this;\n\n        var zone = Zone.current;\n        var isChildOfAmbientZone = false;\n\n        while (zone) {\n          if (zone === ambientZone) {\n            isChildOfAmbientZone = true;\n            break;\n          }\n\n          zone = zone.parent;\n        }\n\n        if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n        // It will be a proxy zone, so that the tests function can retroactively install\n        // different zones.\n        // Example:\n        //   - In beforeEach() do childZone = Zone.current.fork(...);\n        //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n        //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n        //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n        //     fakeAsync behavior to the childZone.\n\n        this.testProxyZoneSpec = new ProxyZoneSpec();\n        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n        if (!Zone.currentTask) {\n          // if we are not running in a task then if someone would register a\n          // element.addEventListener and then calling element.click() the\n          // addEventListener callback would think that it is the top most task and would\n          // drain the microtask queue on element.click() which would be incorrect.\n          // For this reason we always force a task when running jasmine tests.\n          Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n            return QueueRunner.prototype.execute.call(_this);\n          });\n        } else {\n          _super.prototype.execute.call(this);\n        }\n      };\n\n      return ZoneQueueRunner;\n    }(QueueRunner);\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('jest', function (context, Zone, api) {\n    if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n      return;\n    }\n\n    jest['__zone_patch__'] = true;\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n    var proxyZoneSpec = new ProxyZoneSpec();\n    var proxyZone = rootZone.fork(proxyZoneSpec);\n\n    function wrapDescribeFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n\n        var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          args[1] = wrapDescribeInZone(args[1]);\n          return originalDescribeFn.apply(this, args);\n        };\n      };\n    }\n\n    function wrapTestFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          args[1] = wrapTestInZone(args[1]);\n          return originalJestFn.apply(this, tableArgs).apply(this, args);\n        };\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return syncZone.run(describeBody, this, args);\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in the `proxyZone`.\n     */\n\n\n    function wrapTestInZone(testBody, isTestFunc) {\n      if (isTestFunc === void 0) {\n        isTestFunc = false;\n      }\n\n      if (typeof testBody !== 'function') {\n        return testBody;\n      }\n\n      var wrappedFunc = function () {\n        if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody && !testBody.isFakeAsync) {\n          // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n          var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n          if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n            testBody = fakeAsyncModule.fakeAsync(testBody);\n          }\n        }\n\n        proxyZoneSpec.isTestFunc = isTestFunc;\n        return proxyZone.run(testBody, null, arguments);\n      }; // Update the length of wrappedFunc to be the same as the length of the testBody\n      // So jest core can handle whether the test function has `done()` or not correctly\n\n\n      Object.defineProperty(wrappedFunc, 'length', {\n        configurable: true,\n        writable: true,\n        enumerable: false\n      });\n      wrappedFunc.length = testBody.length;\n      return wrappedFunc;\n    }\n\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n    });\n    context.describe.only = context.fdescribe;\n    context.describe.skip = context.xdescribe;\n    ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[1] = wrapTestInZone(args[1], true);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n      context[methodName].todo = originalJestFn.todo;\n    });\n    context.it.only = context.fit;\n    context.it.skip = context.xit;\n    context.test.only = context.fit;\n    context.test.skip = context.xit;\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[0] = wrapTestInZone(args[0]);\n        return originalJestFn.apply(this, args);\n      };\n    });\n\n    Zone.patchJestObject = function patchJestObject(Timer, isModern) {\n      if (isModern === void 0) {\n        isModern = false;\n      } // check whether currently the test is inside fakeAsync()\n\n\n      function isPatchingFakeTimer() {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        return !!fakeAsyncZoneSpec;\n      } // check whether the current function is inside `test/it` or other methods\n      // such as `describe/beforeEach`\n\n\n      function isInTestFunc() {\n        var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n        return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n      }\n\n      if (Timer[api.symbol('fakeTimers')]) {\n        return;\n      }\n\n      Timer[api.symbol('fakeTimers')] = true; // patch jest fakeTimer internal method to make sure no console.warn print out\n\n      api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n        return function (self, args) {\n          if (isPatchingFakeTimer()) {\n            return true;\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n\n      api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n        return function (self, args) {\n          Zone[api.symbol('useFakeTimersCalled')] = true;\n\n          if (isModern || isInTestFunc()) {\n            return delegate.apply(self, args);\n          }\n\n          return self;\n        };\n      }); // patch useRealTimers(), unset useFakeTimers flag\n\n      api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n        return function (self, args) {\n          Zone[api.symbol('useFakeTimersCalled')] = false;\n\n          if (isModern || isInTestFunc()) {\n            return delegate.apply(self, args);\n          }\n\n          return self;\n        };\n      }); // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n            fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n            return fakeAsyncZoneSpec.getRealSystemTime();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runAllTicks(), run all microTasks inside fakeAsync\n\n      api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flushMicrotasks();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runAllTimers(), run all macroTasks inside fakeAsync\n\n      api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flush(100, true);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.tick(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flushOnlyPendingTimers();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.tickToNext(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.removeAllTimers();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            return fakeAsyncZoneSpec.getTimerCount();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n    };\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('mocha', function (global, Zone) {\n    var Mocha = global.Mocha;\n\n    if (typeof Mocha === 'undefined') {\n      // return if Mocha is not available, because now zone-testing\n      // will load mocha patch with jasmine/jest patch\n      return;\n    }\n\n    if (typeof Zone === 'undefined') {\n      throw new Error('Missing Zone.js');\n    }\n\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    if (Mocha['__zone_patch__']) {\n      throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n    }\n\n    Mocha['__zone_patch__'] = true;\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n    var testZone = null;\n    var suiteZone = rootZone.fork(new ProxyZoneSpec());\n    var mochaOriginal = {\n      after: global.after,\n      afterEach: global.afterEach,\n      before: global.before,\n      beforeEach: global.beforeEach,\n      describe: global.describe,\n      it: global.it\n    };\n\n    function modifyArguments(args, syncTest, asyncTest) {\n      var _loop_1 = function (i) {\n        var arg = args[i];\n\n        if (typeof arg === 'function') {\n          // The `done` callback is only passed through if the function expects at\n          // least one argument.\n          // Note we have to make a function with correct number of arguments,\n          // otherwise mocha will\n          // think that all functions are sync or async.\n          args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg); // Mocha uses toString to view the test body in the result list, make sure we return the\n          // correct function body\n\n          args[i].toString = function () {\n            return arg.toString();\n          };\n        }\n      };\n\n      for (var i = 0; i < args.length; i++) {\n        _loop_1(i);\n      }\n\n      return args;\n    }\n\n    function wrapDescribeInZone(args) {\n      var syncTest = function (fn) {\n        return function () {\n          return syncZone.run(fn, this, arguments);\n        };\n      };\n\n      return modifyArguments(args, syncTest);\n    }\n\n    function wrapTestInZone(args) {\n      var asyncTest = function (fn) {\n        return function (done) {\n          return testZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function (fn) {\n        return function () {\n          return testZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    function wrapSuiteInZone(args) {\n      var asyncTest = function (fn) {\n        return function (done) {\n          return suiteZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function (fn) {\n        return function () {\n          return suiteZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    global.describe = global.suite = function () {\n      return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.xdescribe = global.suite.skip = function () {\n      return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.describe.only = global.suite.only = function () {\n      return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.it = global.specify = global.test = function () {\n      return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.xit = global.xspecify = function () {\n      return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.it.only = global.test.only = function () {\n      return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.after = global.suiteTeardown = function () {\n      return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.afterEach = global.teardown = function () {\n      return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.before = global.suiteSetup = function () {\n      return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.beforeEach = global.setup = function () {\n      return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    (function (originalRunTest, originalRun) {\n      Mocha.Runner.prototype.runTest = function (fn) {\n        var _this = this;\n\n        Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n          originalRunTest.call(_this, fn);\n        });\n      };\n\n      Mocha.Runner.prototype.run = function (fn) {\n        this.on('test', function (e) {\n          testZone = rootZone.fork(new ProxyZoneSpec());\n        });\n        this.on('fail', function (test, err) {\n          var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n\n          if (proxyZoneSpec && err) {\n            try {\n              // try catch here in case err.message is not writable\n              err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n            } catch (error) {}\n          }\n        });\n        return originalRun.call(this, fn);\n      };\n    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (_global) {\n    var AsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this.entryFunction = null;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = {\n          'AsyncTestZoneSpec': this\n        };\n        this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n      }\n\n      AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n        return this.unresolvedChainedPromiseCount > 0;\n      };\n\n      AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n        var _this = this;\n\n        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n          // We do this because we would like to catch unhandled rejected promises.\n          this.runZone.run(function () {\n            setTimeout(function () {\n              if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                _this.finishCallback();\n              }\n            }, 0);\n          });\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n        if (patchPromiseForTest) {\n          patchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n        if (unPatchPromiseForTest) {\n          unPatchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n          // check whether the promise is a chained promise\n          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n            // chained promise is being scheduled\n            this.unresolvedChainedPromiseCount--;\n          }\n        }\n\n        return delegate.scheduleTask(target, task);\n      };\n\n      AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      };\n\n      AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.cancelTask(target, task);\n      }; // Note - we need to use onInvoke at the moment to call finish when a test is\n      // fully synchronous. TODO(juliemr): remove this when the logic for\n      // onHasTask changes and it calls whenever the task queues are dirty.\n      // updated by(JiaLiPassion), only call finish callback when no task\n      // was scheduled/invoked/canceled.\n\n\n      AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        if (!this.entryFunction) {\n          this.entryFunction = delegate;\n        }\n\n        try {\n          this._isSync = true;\n          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        } finally {\n          parentZoneDelegate._taskCounts; // We need to check the delegate is the same as entryFunction or not.\n          // Consider the following case.\n          //\n          // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n          //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n          //   });\n          // });\n          //\n          // We only want to check whether there are async tasks scheduled\n          // for the entry function.\n\n          if (this._isSync && this.entryFunction === delegate) {\n            this._finishCallbackIfDone();\n          }\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        var result = parentZoneDelegate.handleError(targetZone, error);\n\n        if (result) {\n          this.failCallback(error);\n          this._alreadyErrored = true;\n        }\n\n        return false;\n      };\n\n      AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState); // We should only trigger finishCallback when the target zone is the AsyncTestZone\n        // Consider the following cases.\n        //\n        // const childZone = asyncTestZone.fork({\n        //   name: 'child',\n        //   onHasTask: ...\n        // });\n        //\n        // So we have nested zones declared the onHasTask hook, in this case,\n        // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n        // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n        // when the current zone is the same as the target zone.\n\n        if (current !== target) {\n          return;\n        }\n\n        if (hasTaskState.change == 'microTask') {\n          this._pendingMicroTasks = hasTaskState.microTask;\n\n          this._finishCallbackIfDone();\n        } else if (hasTaskState.change == 'macroTask') {\n          this._pendingMacroTasks = hasTaskState.macroTask;\n\n          this._finishCallbackIfDone();\n        }\n      };\n\n      return AsyncTestZoneSpec;\n    }();\n\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n  Zone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n      // If we're running using the Jasmine test framework, adapt to call the 'done'\n      // function when asynchronous activity is finished.\n      if (global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n          if (!done) {\n            // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n            // fake it here and assume sync.\n            done = function () {};\n\n            done.fail = function (e) {\n              throw e;\n            };\n          }\n\n          runInTestZone(fn, this, done, function (err) {\n            if (typeof err === 'string') {\n              return done.fail(new Error(err));\n            } else {\n              done.fail(err);\n            }\n          });\n        };\n      } // Otherwise, return a promise which will resolve when asynchronous activity\n      // is finished. This will be correctly consumed by the Mocha framework with\n      // it('...', async(myFn)); or can be used in a custom framework.\n      // Not using an arrow function to preserve context passed from call site\n\n\n      return function () {\n        var _this = this;\n\n        return new Promise(function (finishCallback, failCallback) {\n          runInTestZone(fn, _this, finishCallback, failCallback);\n        });\n      };\n    };\n\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n      var currentZone = Zone.current;\n      var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n      if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/async-test');\n      }\n\n      var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n      }\n\n      var proxyZoneSpec = ProxyZoneSpec.get();\n      ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n      // If we do it in ProxyZone then we will get to infinite recursion.\n\n      var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n      var previousDelegate = proxyZoneSpec.getDelegate();\n      proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's\n            // sill this one. Otherwise, assume\n            // it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            finishCallback();\n          });\n        }, function (error) {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            failCallback(error);\n          });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n        testZoneSpec.patchPromiseForTest();\n      });\n      return Zone.current.runGuarded(fn, context);\n    }\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (global) {\n    var OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n\n    function FakeDate() {\n      if (arguments.length === 0) {\n        var d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n      } else {\n        var args = Array.prototype.slice.call(arguments);\n        return new (OriginalDate.bind.apply(OriginalDate, __spreadArray([void 0], args, false)))();\n      }\n    }\n\n    FakeDate.now = function () {\n      var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getFakeSystemTime();\n      }\n\n      return OriginalDate.now.apply(this, arguments);\n    };\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler =\n    /** @class */\n    function () {\n      function Scheduler() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTickTime = 0; // Current fake system base time in millis.\n\n        this._currentFakeBaseSystemTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      Scheduler.prototype.getCurrentTickTime = function () {\n        return this._currentTickTime;\n      };\n\n      Scheduler.prototype.getFakeSystemTime = function () {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n      };\n\n      Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n      };\n\n      Scheduler.prototype.getRealSystemTime = function () {\n        return OriginalDate.now();\n      };\n\n      Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n        options = Object.assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTickTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n\n        var i = 0;\n\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n\n        this._schedulerQueue.splice(i, 0, newEntry);\n\n        return currentId;\n      };\n\n      Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n\n            break;\n          }\n        }\n      };\n\n      Scheduler.prototype.removeAll = function () {\n        this._schedulerQueue = [];\n      };\n\n      Scheduler.prototype.getTimerCount = function () {\n        return this._schedulerQueue.length;\n      };\n\n      Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n        if (step === void 0) {\n          step = 1;\n        }\n\n        if (this._schedulerQueue.length < step) {\n          return;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n      };\n\n      Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        var finalTime = this._currentTickTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var current_1 = schedulerQueue.shift();\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(current_1);\n\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = current_1.endTime;\n\n            if (doTick) {\n              doTick(this._currentTickTime - lastCurrentTime);\n            }\n\n            var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            } // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n\n        if (doTick) {\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n      };\n\n      Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, {\n          processNewMacroTasksSynchronously: false\n        });\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n        if (limit === void 0) {\n          limit = 20;\n        }\n\n        if (flushPeriodic === void 0) {\n          flushPeriodic = false;\n        }\n\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      };\n\n      Scheduler.prototype.flushPeriodic = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n        var startTime = this._currentTickTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n\n        while (this._schedulerQueue.length > 0) {\n          count++;\n\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          } // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n\n          var current = this._schedulerQueue.shift();\n\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n\n          var retval = current.func.apply(global, current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n\n        return this._currentTickTime - startTime;\n      };\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n        if (trackPendingRequestAnimationFrame === void 0) {\n          trackPendingRequestAnimationFrame = false;\n        }\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone = function () {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n        var _this = this;\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          fn.apply(global, args);\n\n          if (_this._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            } // Flush microtasks only on success.\n\n\n            _this.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          } // Return true if there were no errors, false otherwise.\n\n\n          return _this._lastError === null;\n        };\n      };\n\n      FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n        var index = timers.indexOf(id);\n\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n        var _this = this;\n\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n        if (isTimer === void 0) {\n          isTimer = true;\n        }\n\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n\n        var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n        return this._scheduler.getCurrentTickTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n        return this._scheduler.getFakeSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n        this._scheduler.setFakeBaseSystemTime(realTime);\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n        return this._scheduler.getRealSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.patchDate = function () {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      };\n\n      FakeAsyncTestZoneSpec.resetDate = function () {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n        if (steps === void 0) {\n          steps = 1;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        if (steps <= 0) {\n          return;\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tickToNext(steps, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tick(millis, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n        var _this = this;\n\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        var flushErrors = function () {\n          if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this._resetLastErrorAndThrow();\n          }\n        };\n\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n\n        flushErrors();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        this._scheduler.removeAll();\n\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n        return this._scheduler.getTimerCount() + this._microtasks.length;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n\n            var additionalArgs = void 0;\n\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n\n            break;\n\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n\n                if (macroTaskOption) {\n                  var args_1 = task.data && task.data['args'];\n                  var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n\n                  break;\n                }\n\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n\n            break;\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n\n            return delegate.cancelTask(target, task);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n\n        return null;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      };\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n\n    function getProxyZoneSpec() {\n      return Zone && Zone['ProxyZoneSpec'];\n    }\n\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      var fakeAsyncFn = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var ProxyZoneSpec = getProxyZoneSpec();\n\n        if (!ProxyZoneSpec) {\n          throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n        }\n\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res = void 0;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n\n      fakeAsyncFn.isFakeAsync = true;\n      return fakeAsyncFn;\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick(millis, ignoreNestedTimeout) {\n      if (millis === void 0) {\n        millis = 0;\n      }\n\n      if (ignoreNestedTimeout === void 0) {\n        ignoreNestedTimeout = false;\n      }\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  }, true);\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * Promise for async/fakeAsync zoneSpec test\n   * can support async operation which not supported by zone.js\n   * such as\n   * it ('test jsonp in AsyncZone', async() => {\n   *   new Promise(res => {\n   *     jsonp(url, (data) => {\n   *       // success callback\n   *       res(data);\n   *     });\n   *   }).then((jsonpResult) => {\n   *     // get jsonp result.\n   *\n   *     // user will expect AsyncZoneSpec wait for\n   *     // then, but because jsonp is not zone aware\n   *     // AsyncZone will finish before then is called.\n   *   });\n   * });\n   */\n\n\n  Zone.__load_patch('promisefortest', function (global, Zone, api) {\n    var symbolState = api.symbol('state');\n    var UNRESOLVED = null;\n    var symbolParentUnresolved = api.symbol('parentUnresolved'); // patch Promise.prototype.then to keep an internal\n    // number for tracking unresolved chained promise\n    // we will decrease this number when the parent promise\n    // being resolved/rejected and chained promise was\n    // scheduled as a microTask.\n    // so we can know such kind of chained promise still\n    // not resolved in AsyncTestZone\n\n    Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        return;\n      }\n\n      oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n\n      Promise.prototype.then = function () {\n        var chained = oriThen.apply(this, arguments);\n\n        if (this[symbolState] === UNRESOLVED) {\n          // parent promise is unresolved.\n          var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n\n          if (asyncTestZoneSpec) {\n            asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n            chained[symbolParentUnresolved] = true;\n          }\n        }\n\n        return chained;\n      };\n    };\n\n    Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n      // restore origin then\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        Promise.prototype.then = oriThen;\n        Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n      }\n    };\n  });\n});","map":{"version":3,"sources":["/home/coder/project/workspace/angularapp/node_modules/zone.js/dist/zone-testing.js"],"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","factory","define","amd","NEWLINE","IGNORE_FRAMES","creationTrace","ERROR_TAG","SEP_TAG","sepTemplate","LongStackTrace","error","getStacktrace","timestamp","Date","getStacktraceWithUncaughtError","Error","getStacktraceWithCaughtError","err","caughtError","stack","getFrames","split","addErrorStack","lines","trace","frame","hasOwnProperty","push","renderLongStackTrace","frames","longTrace","trim","getTime","traceFrames","lastTime","separator","replace","join","stackTracesEnabled","stackTraceLimit","Zone","name","longStackTraceLimit","getLongStackTrace","undefined","__symbol__","onScheduleTask","parentZoneDelegate","currentZone","targetZone","task","currentTask","data","type","Object","assign","scheduleTask","onHandleError","parentTask","longStack","handleError","captureStackTraces","stackTraces","count","computeIgnoreFrames","frames1","frames2","frame1","indexOf","match","frame2","ProxyZoneSpec","defaultSpecDelegate","_delegateSpec","properties","propertyKeys","lastTaskState","isNeedToTriggerHasTask","tasks","setDelegate","get","current","isLoaded","assertPresent","delegateSpec","_this","isNewDelegate","forEach","key","keys","k","macroTask","microTask","getDelegate","resetDelegate","tryTriggerHasTask","onHasTask","removeFromTasks","splice","getAndClearPendingTasksInfo","taskInfo","map","dataInfo","source","pendingTasksInfo","onFork","zoneSpec","fork","onIntercept","delegate","intercept","onInvoke","applyThis","applyArgs","invoke","onInvokeTask","invokeTask","onCancelTask","cancelTask","target","hasTaskState","hasTask","SyncTestZoneSpec","namePrefix","runZone","__load_patch","global","api","__extends","d","b","p","__","constructor","create","jest","jasmine","ambientZone","syncZone","symbol","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors_1","GlobalErrors","instance","originalInstall","install","originalHandlers","process","listeners","r","apply","removeAllListeners","h","on","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn_1","clock","originalTick_1","tick","fakeAsyncZoneSpec","originalMockDate_1","mockDate","dateTime","setFakeBaseSystemTime","originalClockFn","FakeAsyncTestZoneSpec","originalCreateSpyObj_1","createSpyObj","args","propertyNames","spyObj","defineProperty_1","defineProperty","obj","attributes","configurable","enumerable","describeBody","run","runInTestZone","testBody","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","message","proxyZoneSpec","execute","zone","isChildOfAmbientZone","parent","context","rootZone","proxyZone","wrapDescribeFactoryInZone","originalJestFn","tableArgs","_i","originalDescribeFn","wrapTestFactoryInZone","isTestFunc","wrappedFunc","isFakeAsync","writable","each","describe","only","fdescribe","skip","xdescribe","todo","it","fit","xit","test","patchJestObject","Timer","isModern","isPatchingFakeTimer","isInTestFunc","patchMethod","self","getRealSystemTime","flushMicrotasks","flush","flushOnlyPendingTimers","tickToNext","removeAllTimers","getTimerCount","Mocha","testZone","suiteZone","mochaOriginal","after","afterEach","before","beforeEach","modifyArguments","syncTest","asyncTest","_loop_1","arg","toString","wrapSuiteInZone","suite","specify","xspecify","suiteTeardown","teardown","suiteSetup","setup","originalRunTest","originalRun","Runner","runTest","e","_global","AsyncTestZoneSpec","finishCallback","failCallback","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","entryFunction","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","isUnresolvedChainedPromisePending","_finishCallbackIfDone","patchPromiseForTest","Promise","unPatchPromiseForTest","symbolParentUnresolved","_taskCounts","result","change","window","fail","getZoneWith","previousDelegate","testZoneSpec","runGuarded","OriginalDate","FakeDate","setTime","now","bind","fakeAsyncTestZoneSpec","getFakeSystemTime","UTC","parse","timers","setInterval","clearInterval","Scheduler","_schedulerQueue","_currentTickTime","_currentFakeBaseSystemTime","_currentTickRequeuePeriodicEntries","getCurrentTickTime","fakeBaseSystemTime","scheduleFunction","cb","delay","options","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","currentEntry","removeScheduledFunctionWithId","removeAll","step","doTick","tickOptions","startTime","targetTask","millis","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","current_1","shift","idx","retval","lastTask","limit","flushPeriodic","flushNonPeriodic","filter","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","pendingPeriodicTimers","pendingTimers","patchDateLocked","assertInZone","_fnAndFlush","completers","onSuccess","onError","_removeTimer","index","_dequeueTimer","_requeuePeriodicTimer","interval","_dequeuePeriodicTimer","_setTimeout","isTimer","removeTimerFn","_clearTimeout","_setInterval","_clearInterval","_resetLastErrorAndThrow","realTime","patchDate","checkTimerPatch","resetDate","lockDatePatch","unlockDatePatch","steps","flushErrors","microtask","elapsed","additionalArgs","callbackIndex","cbIdx","macroTaskOption","findMacroTaskOption","args_1","callbackArgs","handleId","callback","getProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","fakeAsyncFn","res","lastProxyZoneSpec","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","symbolState","UNRESOLVED","oriThen","then","chained","asyncTestZoneSpec","unpatchPromiseForTest"],"mappings":"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","sourcesContent":["'use strict';\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @license Angular v14.0.0-next.5\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n})((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {globalThis}\n     */\n    var NEWLINE = '\\n';\n    var IGNORE_FRAMES = {};\n    var creationTrace = '__creationTrace__';\n    var ERROR_TAG = 'STACKTRACE TRACKING';\n    var SEP_TAG = '__SEP_TAG__';\n    var sepTemplate = SEP_TAG + '@[native]';\n    var LongStackTrace = /** @class */ (function () {\n        function LongStackTrace() {\n            this.error = getStacktrace();\n            this.timestamp = new Date();\n        }\n        return LongStackTrace;\n    }());\n    function getStacktraceWithUncaughtError() {\n        return new Error(ERROR_TAG);\n    }\n    function getStacktraceWithCaughtError() {\n        try {\n            throw getStacktraceWithUncaughtError();\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    // Some implementations of exception handling don't create a stack trace if the exception\n    // isn't thrown, however it's faster not to actually throw the exception.\n    var error = getStacktraceWithUncaughtError();\n    var caughtError = getStacktraceWithCaughtError();\n    var getStacktrace = error.stack ?\n        getStacktraceWithUncaughtError :\n        (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\n    function getFrames(error) {\n        return error.stack ? error.stack.split(NEWLINE) : [];\n    }\n    function addErrorStack(lines, error) {\n        var trace = getFrames(error);\n        for (var i = 0; i < trace.length; i++) {\n            var frame = trace[i];\n            // Filter out the Frames which are part of stack capturing.\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n                lines.push(trace[i]);\n            }\n        }\n    }\n    function renderLongStackTrace(frames, stack) {\n        var longTrace = [stack ? stack.trim() : ''];\n        if (frames) {\n            var timestamp = new Date().getTime();\n            for (var i = 0; i < frames.length; i++) {\n                var traceFrames = frames[i];\n                var lastTime = traceFrames.timestamp;\n                var separator = \"____________________Elapsed \".concat(timestamp - lastTime.getTime(), \" ms; At: \").concat(lastTime);\n                separator = separator.replace(/[^\\w\\d]/g, '_');\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n                addErrorStack(longTrace, traceFrames.error);\n                timestamp = lastTime.getTime();\n            }\n        }\n        return longTrace.join(NEWLINE);\n    }\n    // if Error.stackTraceLimit is 0, means stack trace\n    // is disabled, so we don't need to generate long stack trace\n    // this will improve performance in some test(some test will\n    // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n    function stackTracesEnabled() {\n        // Cast through any since this property only exists on Error in the nodejs\n        // typings.\n        return Error.stackTraceLimit > 0;\n    }\n    Zone['longStackTraceZoneSpec'] = {\n        name: 'long-stack-trace',\n        longStackTraceLimit: 10,\n        // add a getLongStackTrace method in spec to\n        // handle handled reject promise error.\n        getLongStackTrace: function (error) {\n            if (!error) {\n                return undefined;\n            }\n            var trace = error[Zone.__symbol__('currentTaskTrace')];\n            if (!trace) {\n                return error.stack;\n            }\n            return renderLongStackTrace(trace, error.stack);\n        },\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (stackTracesEnabled()) {\n                var currentTask = Zone.currentTask;\n                var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n                trace = [new LongStackTrace()].concat(trace);\n                if (trace.length > this.longStackTraceLimit) {\n                    trace.length = this.longStackTraceLimit;\n                }\n                if (!task.data)\n                    task.data = {};\n                if (task.type === 'eventTask') {\n                    // Fix issue https://github.com/angular/zone.js/issues/1195,\n                    // For event task of browser, by default, all task will share a\n                    // singleton instance of data object, we should create a new one here\n                    // The cast to `any` is required to workaround a closure bug which wrongly applies\n                    // URL sanitization rules to .data access.\n                    task.data = Object.assign({}, task.data);\n                }\n                task.data[creationTrace] = trace;\n            }\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        },\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (stackTracesEnabled()) {\n                var parentTask = Zone.currentTask || error.task;\n                if (error instanceof Error && parentTask) {\n                    var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                    try {\n                        error.stack = error.longStack = longStack;\n                    }\n                    catch (err) {\n                    }\n                }\n            }\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    };\n    function captureStackTraces(stackTraces, count) {\n        if (count > 0) {\n            stackTraces.push(getFrames((new LongStackTrace()).error));\n            captureStackTraces(stackTraces, count - 1);\n        }\n    }\n    function computeIgnoreFrames() {\n        if (!stackTracesEnabled()) {\n            return;\n        }\n        var frames = [];\n        captureStackTraces(frames, 2);\n        var frames1 = frames[0];\n        var frames2 = frames[1];\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            if (frame1.indexOf(ERROR_TAG) == -1) {\n                var match = frame1.match(/^\\s*at\\s+/);\n                if (match) {\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                    break;\n                }\n            }\n        }\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            var frame2 = frames2[i];\n            if (frame1 === frame2) {\n                IGNORE_FRAMES[frame1] = true;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    computeIgnoreFrames();\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ProxyZoneSpec = /** @class */ (function () {\n        function ProxyZoneSpec(defaultSpecDelegate) {\n            if (defaultSpecDelegate === void 0) { defaultSpecDelegate = null; }\n            this.defaultSpecDelegate = defaultSpecDelegate;\n            this.name = 'ProxyZone';\n            this._delegateSpec = null;\n            this.properties = { 'ProxyZoneSpec': this };\n            this.propertyKeys = null;\n            this.lastTaskState = null;\n            this.isNeedToTriggerHasTask = false;\n            this.tasks = [];\n            this.setDelegate(defaultSpecDelegate);\n        }\n        ProxyZoneSpec.get = function () {\n            return Zone.current.get('ProxyZoneSpec');\n        };\n        ProxyZoneSpec.isLoaded = function () {\n            return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n        };\n        ProxyZoneSpec.assertPresent = function () {\n            if (!ProxyZoneSpec.isLoaded()) {\n                throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n            }\n            return ProxyZoneSpec.get();\n        };\n        ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n            var _this = this;\n            var isNewDelegate = this._delegateSpec !== delegateSpec;\n            this._delegateSpec = delegateSpec;\n            this.propertyKeys && this.propertyKeys.forEach(function (key) { return delete _this.properties[key]; });\n            this.propertyKeys = null;\n            if (delegateSpec && delegateSpec.properties) {\n                this.propertyKeys = Object.keys(delegateSpec.properties);\n                this.propertyKeys.forEach(function (k) { return _this.properties[k] = delegateSpec.properties[k]; });\n            }\n            // if a new delegateSpec was set, check if we need to trigger hasTask\n            if (isNewDelegate && this.lastTaskState &&\n                (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n                this.isNeedToTriggerHasTask = true;\n            }\n        };\n        ProxyZoneSpec.prototype.getDelegate = function () {\n            return this._delegateSpec;\n        };\n        ProxyZoneSpec.prototype.resetDelegate = function () {\n            this.getDelegate();\n            this.setDelegate(this.defaultSpecDelegate);\n        };\n        ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n            if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n                // last delegateSpec has microTask or macroTask\n                // should call onHasTask in current delegateSpec\n                this.isNeedToTriggerHasTask = false;\n                this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n            }\n        };\n        ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n            if (!this.tasks) {\n                return;\n            }\n            for (var i = 0; i < this.tasks.length; i++) {\n                if (this.tasks[i] === task) {\n                    this.tasks.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n            if (this.tasks.length === 0) {\n                return '';\n            }\n            var taskInfo = this.tasks.map(function (task) {\n                var dataInfo = task.data &&\n                    Object.keys(task.data)\n                        .map(function (key) {\n                        return key + ':' + task.data[key];\n                    })\n                        .join(',');\n                return \"type: \".concat(task.type, \", source: \").concat(task.source, \", args: {\").concat(dataInfo, \"}\");\n            });\n            var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n            // clear tasks\n            this.tasks = [];\n            return pendingTasksInfo;\n        };\n        ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n            if (this._delegateSpec && this._delegateSpec.onFork) {\n                return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n            }\n            else {\n                return parentZoneDelegate.fork(targetZone, zoneSpec);\n            }\n        };\n        ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n            if (this._delegateSpec && this._delegateSpec.onIntercept) {\n                return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n            }\n            else {\n                return parentZoneDelegate.intercept(targetZone, delegate, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvoke) {\n                return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n            }\n            else {\n                return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (this._delegateSpec && this._delegateSpec.onHandleError) {\n                return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n            }\n            else {\n                return parentZoneDelegate.handleError(targetZone, error);\n            }\n        };\n        ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.tasks.push(task);\n            }\n            if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n                return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.scheduleTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n                return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n            }\n            else {\n                return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n            }\n        };\n        ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n                return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.cancelTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n            this.lastTaskState = hasTaskState;\n            if (this._delegateSpec && this._delegateSpec.onHasTask) {\n                this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n            }\n            else {\n                delegate.hasTask(target, hasTaskState);\n            }\n        };\n        return ProxyZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var SyncTestZoneSpec = /** @class */ (function () {\n        function SyncTestZoneSpec(namePrefix) {\n            this.runZone = Zone.current;\n            this.name = 'syncTestZone for ' + namePrefix;\n        }\n        SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                case 'macroTask':\n                    throw new Error(\"Cannot call \".concat(task.source, \" from within a sync test.\"));\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        };\n        return SyncTestZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jasmine', function (global, Zone, api) {\n        var __extends = function (d, b) {\n            for (var p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() {\n                this.constructor = d;\n            }\n            d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        var ambientZone = Zone.current;\n        // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n        // error if any asynchronous operations are attempted inside of a `describe` but outside of\n        // a `beforeEach` or `it`.\n        var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n        var symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n        // automatically disable the auto jump into fakeAsync feature\n        var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            ((global[symbol('fakeAsyncPatchLock')] === true) ||\n                (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n        var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            var globalErrors_1 = jasmine.GlobalErrors;\n            if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors_1;\n                jasmine.GlobalErrors = function () {\n                    var instance = new globalErrors_1();\n                    var originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            var originalHandlers = process.listeners('unhandledRejection');\n                            var r = originalInstall.apply(this, arguments);\n                            process.removeAllListeners('unhandledRejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach(function (h) { return process.on('unhandledRejection', h); });\n                            }\n                            return r;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        var jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            var originalClockFn_1 = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                var clock = originalClockFn_1.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    var originalTick_1 = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick_1.apply(this, arguments);\n                    };\n                    var originalMockDate_1 = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                                arguments);\n                        }\n                        return originalMockDate_1.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach(function (methodName) {\n                            var originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        // monkey patch createSpyObj to make properties enumerable to true\n        if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n            var originalCreateSpyObj_1 = jasmine.createSpyObj;\n            jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n            jasmine.createSpyObj = function () {\n                var args = Array.prototype.slice.call(arguments);\n                var propertyNames = args.length >= 3 ? args[2] : null;\n                var spyObj;\n                if (propertyNames) {\n                    var defineProperty_1 = Object.defineProperty;\n                    Object.defineProperty = function (obj, p, attributes) {\n                        return defineProperty_1.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));\n                    };\n                    try {\n                        spyObj = originalCreateSpyObj_1.apply(this, args);\n                    }\n                    finally {\n                        Object.defineProperty = defineProperty_1;\n                    }\n                }\n                else {\n                    spyObj = originalCreateSpyObj_1.apply(this, args);\n                }\n                return spyObj;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            queueRunner.testProxyZoneSpec;\n            var testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody && (testBody.length ? function (done) {\n                return runInTestZone(testBody, this, this.queueRunner, done);\n            } : function () {\n                return runInTestZone(testBody, this, this.queueRunner);\n            }));\n        }\n        var QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                var _this = this;\n                if (attrs.onComplete) {\n                    attrs.onComplete = (function (fn) { return function () {\n                        // All functions are done, clear the test zone.\n                        _this.testProxyZone = null;\n                        _this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    }; })(attrs.onComplete);\n                }\n                var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                var onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        var proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) {\n                            }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                var _this = this;\n                var zone = Zone.current;\n                var isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () { return QueueRunner.prototype.execute.call(_this); });\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jest', function (context, Zone, api) {\n        if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n            return;\n        }\n        jest['__zone_patch__'] = true;\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n        var proxyZoneSpec = new ProxyZoneSpec();\n        var proxyZone = rootZone.fork(proxyZoneSpec);\n        function wrapDescribeFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapDescribeInZone(args[1]);\n                    return originalDescribeFn.apply(this, args);\n                };\n            };\n        }\n        function wrapTestFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapTestInZone(args[1]);\n                    return originalJestFn.apply(this, tableArgs).apply(this, args);\n                };\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return syncZone.run(describeBody, this, args);\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in the `proxyZone`.\n         */\n        function wrapTestInZone(testBody, isTestFunc) {\n            if (isTestFunc === void 0) { isTestFunc = false; }\n            if (typeof testBody !== 'function') {\n                return testBody;\n            }\n            var wrappedFunc = function () {\n                if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody &&\n                    !testBody.isFakeAsync) {\n                    // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n                    var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                    if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                        testBody = fakeAsyncModule.fakeAsync(testBody);\n                    }\n                }\n                proxyZoneSpec.isTestFunc = isTestFunc;\n                return proxyZone.run(testBody, null, arguments);\n            };\n            // Update the length of wrappedFunc to be the same as the length of the testBody\n            // So jest core can handle whether the test function has `done()` or not correctly\n            Object.defineProperty(wrappedFunc, 'length', { configurable: true, writable: true, enumerable: false });\n            wrappedFunc.length = testBody.length;\n            return wrappedFunc;\n        }\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n        });\n        context.describe.only = context.fdescribe;\n        context.describe.skip = context.xdescribe;\n        ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapTestInZone(args[1], true);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n            context[methodName].todo = originalJestFn.todo;\n        });\n        context.it.only = context.fit;\n        context.it.skip = context.xit;\n        context.test.only = context.fit;\n        context.test.skip = context.xit;\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[0] = wrapTestInZone(args[0]);\n                return originalJestFn.apply(this, args);\n            };\n        });\n        Zone.patchJestObject = function patchJestObject(Timer, isModern) {\n            if (isModern === void 0) { isModern = false; }\n            // check whether currently the test is inside fakeAsync()\n            function isPatchingFakeTimer() {\n                var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                return !!fakeAsyncZoneSpec;\n            }\n            // check whether the current function is inside `test/it` or other methods\n            // such as `describe/beforeEach`\n            function isInTestFunc() {\n                var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n                return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n            }\n            if (Timer[api.symbol('fakeTimers')]) {\n                return;\n            }\n            Timer[api.symbol('fakeTimers')] = true;\n            // patch jest fakeTimer internal method to make sure no console.warn print out\n            api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n                return function (self, args) {\n                    if (isPatchingFakeTimer()) {\n                        return true;\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n            api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = true;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch useRealTimers(), unset useFakeTimers flag\n            api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = false;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        return fakeAsyncZoneSpec.getRealSystemTime();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTicks(), run all microTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushMicrotasks();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTimers(), run all macroTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flush(100, true);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tick(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushOnlyPendingTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tickToNext(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.removeAllTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        return fakeAsyncZoneSpec.getTimerCount();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n        };\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('mocha', function (global, Zone) {\n        var Mocha = global.Mocha;\n        if (typeof Mocha === 'undefined') {\n            // return if Mocha is not available, because now zone-testing\n            // will load mocha patch with jasmine/jest patch\n            return;\n        }\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        if (Mocha['__zone_patch__']) {\n            throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n        }\n        Mocha['__zone_patch__'] = true;\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n        var testZone = null;\n        var suiteZone = rootZone.fork(new ProxyZoneSpec());\n        var mochaOriginal = {\n            after: global.after,\n            afterEach: global.afterEach,\n            before: global.before,\n            beforeEach: global.beforeEach,\n            describe: global.describe,\n            it: global.it\n        };\n        function modifyArguments(args, syncTest, asyncTest) {\n            var _loop_1 = function (i) {\n                var arg = args[i];\n                if (typeof arg === 'function') {\n                    // The `done` callback is only passed through if the function expects at\n                    // least one argument.\n                    // Note we have to make a function with correct number of arguments,\n                    // otherwise mocha will\n                    // think that all functions are sync or async.\n                    args[i] = (arg.length === 0) ? syncTest(arg) : asyncTest(arg);\n                    // Mocha uses toString to view the test body in the result list, make sure we return the\n                    // correct function body\n                    args[i].toString = function () {\n                        return arg.toString();\n                    };\n                }\n            };\n            for (var i = 0; i < args.length; i++) {\n                _loop_1(i);\n            }\n            return args;\n        }\n        function wrapDescribeInZone(args) {\n            var syncTest = function (fn) {\n                return function () {\n                    return syncZone.run(fn, this, arguments);\n                };\n            };\n            return modifyArguments(args, syncTest);\n        }\n        function wrapTestInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) {\n                    return testZone.run(fn, this, [done]);\n                };\n            };\n            var syncTest = function (fn) {\n                return function () {\n                    return testZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        function wrapSuiteInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) {\n                    return suiteZone.run(fn, this, [done]);\n                };\n            };\n            var syncTest = function (fn) {\n                return function () {\n                    return suiteZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        global.describe = global.suite = function () {\n            return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.xdescribe = global.suite.skip = function () {\n            return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.describe.only = global.suite.only = function () {\n            return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.it = global.specify = global.test = function () {\n            return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n        };\n        global.xit = global.xspecify = function () {\n            return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n        };\n        global.it.only = global.test.only = function () {\n            return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n        };\n        global.after = global.suiteTeardown = function () {\n            return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.afterEach = global.teardown = function () {\n            return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n        };\n        global.before = global.suiteSetup = function () {\n            return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.beforeEach = global.setup = function () {\n            return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n        };\n        (function (originalRunTest, originalRun) {\n            Mocha.Runner.prototype.runTest = function (fn) {\n                var _this = this;\n                Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n                    originalRunTest.call(_this, fn);\n                });\n            };\n            Mocha.Runner.prototype.run = function (fn) {\n                this.on('test', function (e) {\n                    testZone = rootZone.fork(new ProxyZoneSpec());\n                });\n                this.on('fail', function (test, err) {\n                    var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                    if (proxyZoneSpec && err) {\n                        try {\n                            // try catch here in case err.message is not writable\n                            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                        }\n                        catch (error) {\n                        }\n                    }\n                });\n                return originalRun.call(this, fn);\n            };\n        })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (_global) {\n        var AsyncTestZoneSpec = /** @class */ (function () {\n            function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n                this.finishCallback = finishCallback;\n                this.failCallback = failCallback;\n                this._pendingMicroTasks = false;\n                this._pendingMacroTasks = false;\n                this._alreadyErrored = false;\n                this._isSync = false;\n                this.entryFunction = null;\n                this.runZone = Zone.current;\n                this.unresolvedChainedPromiseCount = 0;\n                this.supportWaitUnresolvedChainedPromise = false;\n                this.name = 'asyncTestZone for ' + namePrefix;\n                this.properties = { 'AsyncTestZoneSpec': this };\n                this.supportWaitUnresolvedChainedPromise =\n                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n            }\n            AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n                return this.unresolvedChainedPromiseCount > 0;\n            };\n            AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n                var _this = this;\n                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                    (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                    // We do this because we would like to catch unhandled rejected promises.\n                    this.runZone.run(function () {\n                        setTimeout(function () {\n                            if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                                _this.finishCallback();\n                            }\n                        }, 0);\n                    });\n                }\n            };\n            AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n                if (patchPromiseForTest) {\n                    patchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n                if (unPatchPromiseForTest) {\n                    unPatchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                    // check whether the promise is a chained promise\n                    if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                        // chained promise is being scheduled\n                        this.unresolvedChainedPromiseCount--;\n                    }\n                }\n                return delegate.scheduleTask(target, task);\n            };\n            AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            };\n            AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.cancelTask(target, task);\n            };\n            // Note - we need to use onInvoke at the moment to call finish when a test is\n            // fully synchronous. TODO(juliemr): remove this when the logic for\n            // onHasTask changes and it calls whenever the task queues are dirty.\n            // updated by(JiaLiPassion), only call finish callback when no task\n            // was scheduled/invoked/canceled.\n            AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n                if (!this.entryFunction) {\n                    this.entryFunction = delegate;\n                }\n                try {\n                    this._isSync = true;\n                    return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n                }\n                finally {\n                    parentZoneDelegate._taskCounts;\n                    // We need to check the delegate is the same as entryFunction or not.\n                    // Consider the following case.\n                    //\n                    // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n                    //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n                    //   });\n                    // });\n                    //\n                    // We only want to check whether there are async tasks scheduled\n                    // for the entry function.\n                    if (this._isSync && this.entryFunction === delegate) {\n                        this._finishCallbackIfDone();\n                    }\n                }\n            };\n            AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                // Let the parent try to handle the error.\n                var result = parentZoneDelegate.handleError(targetZone, error);\n                if (result) {\n                    this.failCallback(error);\n                    this._alreadyErrored = true;\n                }\n                return false;\n            };\n            AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n                delegate.hasTask(target, hasTaskState);\n                // We should only trigger finishCallback when the target zone is the AsyncTestZone\n                // Consider the following cases.\n                //\n                // const childZone = asyncTestZone.fork({\n                //   name: 'child',\n                //   onHasTask: ...\n                // });\n                //\n                // So we have nested zones declared the onHasTask hook, in this case,\n                // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n                // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n                // when the current zone is the same as the target zone.\n                if (current !== target) {\n                    return;\n                }\n                if (hasTaskState.change == 'microTask') {\n                    this._pendingMicroTasks = hasTaskState.microTask;\n                    this._finishCallbackIfDone();\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    this._pendingMacroTasks = hasTaskState.macroTask;\n                    this._finishCallbackIfDone();\n                }\n            };\n            return AsyncTestZoneSpec;\n        }());\n        AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n    Zone.__load_patch('asynctest', function (global, Zone, api) {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) {\n                            throw e;\n                        };\n                    }\n                    runInTestZone(fn, this, done, function (err) {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                var _this = this;\n                return new Promise(function (finishCallback, failCallback) {\n                    runInTestZone(fn, _this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            var currentZone = Zone.current;\n            var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/async-test');\n            }\n            var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (!ProxyZoneSpec) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/proxy');\n            }\n            var proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            var previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(function () {\n                var testZoneSpec = new AsyncTestZoneSpec(function () {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // sill this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        finishCallback();\n                    });\n                }, function (error) {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        failCallback(error);\n                    });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        var OriginalDate = global.Date;\n        // Since when we compile this file to `es2015`, and if we define\n        // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n        // there will be an error which is `Cannot assign to read only property 'prototype'`\n        // so we need to use function implementation here.\n        function FakeDate() {\n            if (arguments.length === 0) {\n                var d = new OriginalDate();\n                d.setTime(FakeDate.now());\n                return d;\n            }\n            else {\n                var args = Array.prototype.slice.call(arguments);\n                return new (OriginalDate.bind.apply(OriginalDate, __spreadArray([void 0], args, false)))();\n            }\n        }\n        FakeDate.now = function () {\n            var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (fakeAsyncTestZoneSpec) {\n                return fakeAsyncTestZoneSpec.getFakeSystemTime();\n            }\n            return OriginalDate.now.apply(this, arguments);\n        };\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        var timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        var Scheduler = /** @class */ (function () {\n            function Scheduler() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTickTime = 0;\n                // Current fake system base time in millis.\n                this._currentFakeBaseSystemTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            Scheduler.prototype.getCurrentTickTime = function () {\n                return this._currentTickTime;\n            };\n            Scheduler.prototype.getFakeSystemTime = function () {\n                return this._currentFakeBaseSystemTime + this._currentTickTime;\n            };\n            Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n                this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n            };\n            Scheduler.prototype.getRealSystemTime = function () {\n                return OriginalDate.now();\n            };\n            Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                var endTime = this._currentTickTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                var newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                var i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    var currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            };\n            Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n                for (var i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            Scheduler.prototype.removeAll = function () {\n                this._schedulerQueue = [];\n            };\n            Scheduler.prototype.getTimerCount = function () {\n                return this._schedulerQueue.length;\n            };\n            Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n                if (step === void 0) { step = 1; }\n                if (this._schedulerQueue.length < step) {\n                    return;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var targetTask = this._schedulerQueue[step - 1];\n                this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n            };\n            Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                var finalTime = this._currentTickTime + millis;\n                var lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    var current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        var current_1 = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            var idx = this._schedulerQueue.indexOf(current_1);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTickTime;\n                        this._currentTickTime = current_1.endTime;\n                        if (doTick) {\n                            doTick(this._currentTickTime - lastCurrentTime);\n                        }\n                        var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                                var i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    var currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n            };\n            Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n                if (limit === void 0) { limit = 20; }\n                if (flushPeriodic === void 0) { flushPeriodic = false; }\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            };\n            Scheduler.prototype.flushPeriodic = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n                var startTime = this._currentTickTime;\n                var lastCurrentTime = 0;\n                var count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(function (task) { return !task.isPeriodic && !task.isRequestAnimationFrame; })\n                        .length === 0) {\n                        break;\n                    }\n                    var current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTickTime;\n                    this._currentTickTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTickTime - lastCurrentTime);\n                    }\n                    var retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTickTime - startTime;\n            };\n            return Scheduler;\n        }());\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        var FakeAsyncTestZoneSpec = /** @class */ (function () {\n            function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            FakeAsyncTestZoneSpec.assertInZone = function () {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n                var _this = this;\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    fn.apply(global, args);\n                    if (_this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        _this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return _this._lastError === null;\n                };\n            };\n            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n                var index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n                var _this = this;\n                return function () {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });\n                    }\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n                if (isTimer === void 0) { isTimer = true; }\n                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n                var id = Scheduler.nextId;\n                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                var cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n                var error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            };\n            FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n                return this._scheduler.getCurrentTickTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n                return this._scheduler.getFakeSystemTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n                this._scheduler.setFakeBaseSystemTime(realTime);\n            };\n            FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n                return this._scheduler.getRealSystemTime();\n            };\n            FakeAsyncTestZoneSpec.patchDate = function () {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            };\n            FakeAsyncTestZoneSpec.resetDate = function () {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            };\n            FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n                if (steps === void 0) { steps = 1; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                if (steps <= 0) {\n                    return;\n                }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tickToNext(steps, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n                var _this = this;\n                FakeAsyncTestZoneSpec.assertInZone();\n                var flushErrors = function () {\n                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        _this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    var microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            };\n            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this._scheduler.removeAll();\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n            };\n            FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n                return this._scheduler.getTimerCount() + this._microtasks.length;\n            };\n            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        var args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        var additionalArgs = void 0;\n                        if (args) {\n                            var callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                var macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    var args_1 = task.data && task.data['args'];\n                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            };\n            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        var macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            var handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (var i = 0; i < this.macroTaskOptions.length; i++) {\n                    var macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            };\n            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            };\n            return FakeAsyncTestZoneSpec;\n        }());\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n    Zone.__load_patch('fakeasync', function (global, Zone, api) {\n        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        function getProxyZoneSpec() {\n            return Zone && Zone['ProxyZoneSpec'];\n        }\n        var _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            var fakeAsyncFn = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var ProxyZoneSpec = getProxyZoneSpec();\n                if (!ProxyZoneSpec) {\n                    throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                        'Please make sure that your environment includes zone.js/plugins/proxy');\n                }\n                var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    var res = void 0;\n                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") +\n                            \"periodic timer(s) still in the queue.\");\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n            fakeAsyncFn.isFakeAsync = true;\n            return fakeAsyncFn;\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis, ignoreNestedTimeout) {\n            if (millis === void 0) { millis = 0; }\n            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) {\n            return _getFakeAsyncZoneSpec().flush(maxTurns);\n        }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            var zoneSpec = _getFakeAsyncZoneSpec();\n            zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() {\n            _getFakeAsyncZoneSpec().flushMicrotasks();\n        }\n        Zone[api.symbol('fakeAsyncTest')] =\n            { resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync };\n    }, true);\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Promise for async/fakeAsync zoneSpec test\n     * can support async operation which not supported by zone.js\n     * such as\n     * it ('test jsonp in AsyncZone', async() => {\n     *   new Promise(res => {\n     *     jsonp(url, (data) => {\n     *       // success callback\n     *       res(data);\n     *     });\n     *   }).then((jsonpResult) => {\n     *     // get jsonp result.\n     *\n     *     // user will expect AsyncZoneSpec wait for\n     *     // then, but because jsonp is not zone aware\n     *     // AsyncZone will finish before then is called.\n     *   });\n     * });\n     */\n    Zone.__load_patch('promisefortest', function (global, Zone, api) {\n        var symbolState = api.symbol('state');\n        var UNRESOLVED = null;\n        var symbolParentUnresolved = api.symbol('parentUnresolved');\n        // patch Promise.prototype.then to keep an internal\n        // number for tracking unresolved chained promise\n        // we will decrease this number when the parent promise\n        // being resolved/rejected and chained promise was\n        // scheduled as a microTask.\n        // so we can know such kind of chained promise still\n        // not resolved in AsyncTestZone\n        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                return;\n            }\n            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n            Promise.prototype.then = function () {\n                var chained = oriThen.apply(this, arguments);\n                if (this[symbolState] === UNRESOLVED) {\n                    // parent promise is unresolved.\n                    var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                    if (asyncTestZoneSpec) {\n                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                        chained[symbolParentUnresolved] = true;\n                    }\n                }\n                return chained;\n            };\n        };\n        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n            // restore origin then\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                Promise.prototype.then = oriThen;\n                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n            }\n        };\n    });\n}));\n"]},"metadata":{},"sourceType":"script"}